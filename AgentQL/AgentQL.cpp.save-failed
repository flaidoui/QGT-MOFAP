#include <iostream>
#include <cstdlib>      // std::rand, std::srand
#include <algorithm>    // std::find
#include <sstream>//LF:convert string
#include <ctime>        // std::time
#include <sstream>//LF:convert string
#include <fstream>
//#include <random>
//--------------------------rand répété
#include <cmath>
//---------------------======================
#include "AgentQL.h"

//---------------------------------------
#include "../Individual/Individual.h"
#include "../AFP/AFP.h"
#include "../Commun/Commun.h"


extern bool my_cmpSupDoublePair(const pair <double,double>   &a, const pair <double,double>   &b);
//---------------------------------
 AGENTQL:: AGENTQL(AFP * afpProblem, const int max_gen,int IndexPlayer)//()
   {
       int SizeActions = 5;
        // On choisit le joueur
        if(IndexPlayer == 1)//c'est le joueur PI qui joue
        {
            cout << "Apprentissage lance avec PI" << endl << endl;
            //On définit les paramètres (coeffeicients) d apprentissage
            QGAMMA = 0.9;
            QALPHA = 0.2;

            //###################################################
            //# initialiser l'ensembles des actions (strategy trx, strategie fréquences
                      //lest strategies de fréquences du joueur PI

            ActionsSet.reserve(SizeActions);
           // ActionsSet->reserve();
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ActionsSet.at(0).ActFreq = {1};//stratégie aléatoire de choix de fréquence
             // ActionsSet->at(3).ActFreq = 550;
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ActionsSet.at(1).ActFreq = {2};// choix de la frééquence avec minimum cout
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ActionsSet.at(2).ActFreq  = {550};
             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             ActionsSet.at(3).ActFreq  = {4};//stratégie de choix de fréquence en mode Nash
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               ActionsSet.at(4).ActFreq = {6};//stratégie de choix de fréquence en mode HV
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          // Qtable = new vector < pair < pair < State, Action> , double > > ();
        //  cout << "ActionsSet->size()" << ActionsSet->size()<<endl;

        }
        else if(IndexPlayer == 2)// c'est PS qui joueur(1==0)//
        {
             cout << "Apprentissage lance avec PS" << endl << endl;

            //les valeur des coeffeicient d apprentissage
            QGAMMA = 0.9;
            QALPHA = 0.01;
            //# initialiser l'ensembles des actions (strategy trx, strategie fréquences
            //lest strategies de fréquences du joueur PS
            ActionsSet.reserve(SizeActions);
           // ActionsSet->reserve();
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ActionsSet.at(0).ActFreq = {1};//stratégie aléatoire de choix de fréquence
             // ActionsSet->at(3).ActFreq = 550;
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ActionsSet.at(1).ActFreq = {2};// choix de la frééquence avec minimum cout
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ActionsSet.at(2).ActFreq  = {550};
             //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             ActionsSet.at(3).ActFreq  = {4};//stratégie de choix de fréquence en mode Nash
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               ActionsSet.at(4).ActFreq = {6};//stratégie de choix de fréquence en mode HV
            //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          // Qtable = new vector < pair < pair < State, Action> , double > > ();
        }
        InitQtable(afpProblem,max_gen);

    }


   //---------------------------------------------------
 AGENTQL::~AGENTQL()
  {
   QGAMMA = 0;
  // ActionsSet = NULL;
   //delete ActionsSet;
   //Qtable = NULL;
<<<<<<< HEAD
   //delete
   vector < Action >().swap(ActionsSet);
=======
   //delete
   vector < Action >().swap(ActionsSet);
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad
    vector < pair < pair < State, Action> , double > >().swap(Qtable);

  }
	//-------------------------------------------
    //------------------------------------------------
//Procéédure pour iniyialiser Qtable
void  AGENTQL::InitQtable(AFP * afpProblem, const int max_gen)
{
<<<<<<< HEAD
    Action a; State s; pair <State, Action> p;
     pair < pair < State, Action> , double > pdash;
    int PbSize = afpProblem->trxs.size();
=======
    Action a; State s; pair <State, Action> p;
     pair < pair < State, Action> , double > pdash;
    int PbSize = afpProblem->trxs.size();
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad
    int ActionsSetSize = ActionsSet.size();
    int taille = PbSize * ActionsSetSize;

    //Qtable = vector < pair < pair < State, Action> , double > > (taille) ;
    Qtable.reserve(taille);

   int k = 0;
    for(int i = 0; i < afpProblem->trxs.size(); i++)// taille des étates
    {
<<<<<<< HEAD
        s.UnTreatedTRXNumb = i;
=======
        s.UnTreatedTRXNumb = i;
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad
        p.first = s;
        for(int j = 0 ; j < ActionsSet.size(); j++)
        {
            a.ActFreq = ActionsSet.at(j).ActFreq;
            p.second = a;
            pdash.first = p ;
            pdash.second = 0.0 ;
            //--------------------- pour tester le fctionnementt de cette procedure
           /* if( (i== 1) && (j ==2) )
            {
                 pdash.second = 5.0;
                 cout << " hiii!!!!!!!!!!!!!!!" <<endl;

            }*/
            //===================================================
             //Qtable->push_back(pdash);
             Qtable.at(k) = pdash;
             k = k+1;
            }
        }
   cout << "Qtable->size()" << Qtable.size() << endl;
}
//-----------------------------------------------------------------
//------------------------------------------------
// recupérer l'action;
// il faut choisir une politique pour selectionner la bonne action
// On commence par choisir une action aléatoirement
 Action AGENTQL::GetPossibleAction ()
 {
//TRXs trx;
//on remplie les partie non copié donc si l = solution->plan->size(), cela veut dire on a trouvé une solution complète toute
  // Au début choisir alétoirement un trx
    srand ( unsigned ( time(0) ) );
    int choice;
    //random_device rd;
    //generate secret number between 1 and 2:
    choice = rand() % ActionsSet.size() ;

    // cout << " L'ordre de l'action choisi est : " << choice << endl;

    return ActionsSet.at(choice);
 }
//---------------------------------------------
void AGENTQL::ShowQtable(int ApproachGameEvaluation,string instance,double elapsed_secs,const int  max_gen,const double  epsilon, int IndexPlayer)
{
    ofstream ResultFile; string path;
    if(IndexPlayer == 1)
    {
        path="Resultats/QtablePI_";
    }
    else if (IndexPlayer == 2)
    {
        path="Resultats/QtablePS_";
    }
    string dateTime;
    time_t rawtime;
    struct tm * timeinfo;
    char buffer [80];
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    ostringstream temp;  //temp as in temporary
     stringstream ss;
     int d = timeinfo->tm_mday;
    temp<<"_";
    temp<<d;

    int m = timeinfo->tm_mon;
    m=m+1;
    temp<<"_";
    temp<<m;


    int h = timeinfo->tm_hour;
    temp<<"_";
    temp<<h;
    temp<<"h";

    int mi= timeinfo->tm_min;
    temp<<"_";
    temp<<mi;
    temp<<"min";

    stringstream sss;
    stringstream ssss;
    stringstream sssss;
    sss << max_gen;
    ssss << epsilon;
     sssss << ApproachGameEvaluation;
    path = path+ "_Evaluation_"+sssss.str()+"_epsilon"+ssss.str()+  +"_gen_" + sss.str()+temp.str()+".txt";      //str is temp as string

    ResultFile.open(path.c_str(),std::ios::app);

    if (!ResultFile) {
        cerr << "Unable to open file!!";
        exit(1);   // call system to stop
    }
   ResultFile << " ~~~~~~~~ Qtable is ~~~~~~~~~~~~"   << endl ;
     ResultFile << "size of q table is " << Qtable.size() << endl;
    ResultFile << "size of Actions ****" << ActionsSet.size() << endl;
      ResultFile << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
    int i,j;  pair <State, Action> MyPair;
    State s; Action A; double Qvalue; int taille;
     Individual * solutionTemp;
        //à chaque génération, on initialise  la solution(individual)
        solutionTemp = new Individual();
    if(Qtable.empty() == false)
    {

        for (int i = 0; i < Qtable.size(); i++)//LF comment:initiallement le cout est 0
        {
            MyPair = Qtable.at(i).first;
            s = MyPair.first;
            A = MyPair.second;
            //solutionTemp = s.CurrentSol;
            taille = GetSolutionRealSize(solutionTemp);
            Qvalue = Qtable.at(i).second;
            ResultFile << "Etat : " ;
            ResultFile<< "state  "<< s.UnTreatedTRXNumb << " with Action (FreqStrategy) is (" << A.ActFreq << ")" << endl << endl ;
            ResultFile<< " Qvalue is " << Qvalue << endl << endl ;
            ResultFile << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
            ResultFile << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
        }
    }
    else
    {
        ResultFile<<" The table is empty HONEY !!" <<endl;
    }


    ResultFile.close();


}
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
/*void AGENTQL::ShowQDashtable()
{
    ofstream ResultFile;
    string path = "Resultats/QDashtable";
    string dateTime;
    time_t rawtime;
    struct tm * timeinfo;
    char buffer [80];
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    ostringstream temp;  //temp as in temporary
     stringstream ss;
     int d = timeinfo->tm_mday;
    temp<<"_";
    temp<<d;

    int m = timeinfo->tm_mon;
    m=m+1;
    temp<<"_";
    temp<<m;


    int h = timeinfo->tm_hour;
    temp<<"_";
    temp<<h;
    temp<<"h";

    int mi= timeinfo->tm_min;
    temp<<"_";
    temp<<mi;
    temp<<"min";

    path = path+temp.str()+".txt";      //str is temp as string
    ResultFile.open(path.c_str(),std::ios::app);

    if (!ResultFile) {
        cerr << "Unable to open file!!";
        exit(1);   // call system to stop
    }
   ResultFile << " ~~~~~~~~ Qtable is ~~~~~~~~~~~~"   << endl ;
     ResultFile << "size of q table is " << Qtable->size() << endl;
      ResultFile << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
    int i,j;  pair <State, Action> MyPair;
    State s; Action A; double Qvalue;
    for (int i = 0; i < QDashtable->size(); i++)//LF comment:initiallement le cout est 0
    {
        MyPair = Qtable->at(i).first;
        s = MyPair.first;
        A = MyPair.second;
        Qvalue = Qtable->at(i).second;
        ResultFile << "Etat : " ;

        ResultFile<< " Action (TRXStrategy; FreqStrategy) is (" << A.ActTRX << ";" << A.ActFreq << ")" << endl << endl ;
        ResultFile<< " Qvalue is " << Qvalue << endl << endl ;
        ResultFile << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
        ResultFile << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~" << endl;
    }


    ResultFile.close();


}*/
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
/*bool AGENTQL::CheckAction(Action A)
{
    int i;
    for (i=0; i < ActionsSet->size(); i++)
    {
        if ((ActionsSet->at(i).ActTRX == A.ActTRX) &&  ( ActionsSet->at(i).ActFreq == A.ActFreq))
            return true;
    }
    return false; //if ( i == ActionsSet->size()) return false;
}*/
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
/*bool AGENTQL::CheckElementQtable( pair < State, Action> Mypair, int & IndexElement)
{
    //vector < pair < pair < State, Action> , double > >  Qtable;
    int i;
    pair < pair < State, Action> , double > p;
    pair < State, Action> secondp;
    State MypairState, secondpState;
    Action MypairAct, secondpAct;
    MypairState =  Mypair.first;
    MypairAct = Mypair.second;
    bool test = false;
    IndexElement = -1;
    for (i=0; i < Qtable->size(); i++)
    {
        //on récupère un élément de la table
        p = Qtable->at(i);
        secondp = p.first;
         secondpState = secondp.first;
         secondpAct= secondp.second;
        if (MypairState.UnTreatedTRXNumb == secondpState.UnTreatedTRXNumb)
        {
            if ((MypairAct.ActTRX == secondpAct.ActTRX) and (MypairAct.ActFreq == secondpAct.ActFreq))
            {
                IndexElement = i;
                test = true;
            }
        }


    }

    return test;
}*/
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
//on est dans s (etat après utilisation de l'action a, on calcule la récompense immédiate après l'utilisation de l'action a
void AGENTQL::ObserveReward (int indexplayer,Individual* solref, Individual* sol, double &Reward, string instance)
{
    //on evalue si la contrainte n'est pas violé donc +1 ; sionn si la contrainte est viloé donc +1
    if (indexplayer == 1) // le joueur PI qui est entrin de joueur donc on vérifie si la contrinte de conférence
    {
        if (solref->PIObj <= sol->PIObj)//cela veut dire le choix de la fréquence n'a pas affecté sur le cout d'interference
         //recompense +1
         {
             Reward = + 1;
         }
         else // le choix de la fréquence est mauvais
         {
             Reward = - 1;
         }

    }
     else if (indexplayer == 2) // le joueur PS qui est entrin de joueur donc on vérifie si la contrinte de separation
    {
        if (solref->PSObj <= sol->PSObj)//cela veut dire le choix de la fréquence n'a pas affecté sur le cout de separation
         //recompense +1
         {
             Reward = + 1;
         }
         else // le choix de la fréquence est mauvais
         {
             Reward = - 1;
         }

    }
    else
        cout << " Erreur de choix du joueur dans la phase d'apprentissage!!"<<endl;

  /*
   pair<double,double> Min;
     pair<double,double> Max;
     pair < double, double > R;// est le point de référence ; la valeur max (normalisé)
     if (instance == "Seattle")
    //const pair<double,double> MinSeattle = (4000,15) ;
   {
        Min.first = 4000.0;
        Min.second = 15.0 ;
        Max.first = 70000.0;
        Max.second = 200.0;
        R = Max;
   }
   else
   {
       if (instance == "Denver")
       {
            Min.first = 130000.0;
            Min.second = 1200.0 ;
            Max.first = 300000.0;
            Max.second = 2500.0 ;
            R = Max;
       }
   }
//********************************************************
          // Normaliser les valeurs
    R.first = (R.first - Min.first)/(Max.first-Min.first);
    R.second = (R.second - Min.second)/(Max.second-Min.second);
      vector < pair < double, double > > paircost;
    paircost.reserve(1);
    //Remplir le vecteur par la solution actuelle
    paircost.push_back({sol->PIObj,sol->PSObj});
    Normalize(paircost,Min,Max);
    sort(paircost.begin(),paircost.end(),my_cmpSupDoublePair);
    //on évalue la récompense actuelle qui est l'hypervolume
   // Reward = Hypervolume(paircost,R) ;
   // cout << "&&&&&&&&&&&&&&&&&&&&&&&&reward is&&&&&&&&&&&&&&&& " << Reward << endl;

   if (indexplayer == 1)
   {

       Reward = solref->planCC->at(IndexTRX).first - sol->planCC->at(IndexTRX).first   ;}
   else
   {
       if(indexplayer == 2 )
        {Reward = solref->planCC->at(IndexTRX).second - sol->planCC->at(IndexTRX).second ;}
       else
        cout << " Eroor may be a Virus !!" << endl;
   }
   //on penalise si on  a un cout trop elever

*/
}
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
double AGENTQL::GetMaxQValue(State s, Action & CorrespondingAction)
{//Récupérer la valeur  de Qvalue max et son action

    //vector < pair < pair < State, Action> , double > >  Qtable;
    int i; pair < pair < State, Action> , double > p;
    vector < pair < Action,double > > QValueStateVector;
    pair < State, Action> MyPair; double QValueMax;
   pair < State, Action> MypairMax;
    State MypairStateMax, MyPairState; Action MypairActMax, MyPairAct;
    p = Qtable.at(0);
    MypairMax = p.first;
    MypairStateMax =  MypairMax.first;
    MypairActMax = MypairMax.second;
    QValueMax = p.second;
<<<<<<< HEAD
    vector < pair < Action,double > > QValueActionVector;
=======
    vector < pair < Action,double > > QValueActionVector;
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad
    QValueActionVector.reserve(ActionsSet.size());
    int k = 0;
    for (i=1; i < Qtable.size(); i++)
    {
        p = Qtable.at(i);
         MyPair = p.first;
         MyPairState = MyPair.first;
         MyPairAct = MyPair.second;

        //verifier si l'etat actuelle est l'etat recherchéé
        if (MyPairState.UnTreatedTRXNumb == s.UnTreatedTRXNumb)
        {


        //on sauvegarde toutes les valeur d' actions possible
            //QValueStateVector.push_back({MyPairAct, p.second});
            QValueActionVector[k].first = MyPairAct;
            QValueActionVector[k].second = p.second;
            k++;
          /* if(QValueMax < p.second) //mettre àjour la valeur max de Qvalue
           {
               QValueMax = p.second;
               CorrespondingAction.ActFreq = MyPairAct.ActFreq;
               CorrespondingAction.ActTRX = MyPairAct.ActTRX;
           }*/
        }
        }// fin for

        //rechercher la valeur max dans Qtable
        /*if (QValueStateVector.size() == 0)//il n'y a pas d'hysorique , onchosit aléatoirmenet l'action
        {
             CorrespondingAction = GetPossibleAction();
             QValueMax = 0.0;
        }
        else// l'etat existe deja dans Q table , on retire la valeur max
        {*/
            //cout << " on est ici !!!!!!!!!!!!!"  << endl;
            QValueMax = QValueActionVector[0].second;
            CorrespondingAction.ActFreq = QValueActionVector[0].first.ActFreq;
           // CorrespondingAction.ActTRX = QValueStateVector[0].first.ActTRX;
            for (i=1; i < QValueStateVector.size();i++ )
            {
                if(QValueMax <= QValueStateVector[i].second)
                {
                    QValueMax = QValueStateVector[i].second;
                    CorrespondingAction.ActFreq = QValueStateVector[i].first.ActFreq;
                   // CorrespondingAction.ActTRX = QValueStateVector[i].first.ActTRX;
                }

            }
        //}
    return(QValueMax);
}

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
double AGENTQL::GetQtarget(State sdash , Action & CorrespondingMaxAction)
{
 //int indiceState = GetIndexState(sdash);
 double Qtarget = GetMaxQValue(sdash, CorrespondingMaxAction);
 return Qtarget;
}
//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
/*int AGENTQL::GetIndexState(State s)
{
    int i;
    pair < pair < State, Action> , double > p;
    pair < State, Action> MyPair;
    State MyPairState;

    //------------------------------------------
    for(i=0;i<Qtable->size(); i++)
    {
        p = Qtable->at(i);
        MyPair = p.first;
        MyPairState = MyPair.first;
        if (MyPairState.UnTreatedTRXNumb == s.UnTreatedTRXNumb)
            return i;

    }
}*/




//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
void AGENTQL::UpdateQtable(double Reward, pair < State ,Action > PairStateAction,double Qtarget)
{
    /*double QvaleMax;
    int IndexElement;
    bool check = CheckElementQtable(PairStateAction,IndexElement);
    if (check == true)
        Qtable->at(IndexElement).second =  Qtable->at(IndexElement).second + QALPHA*(Reward + QGAMMA * Qtarget);
    else
<<<<<<< HEAD
        cout << "Element not found in Qtable!!" << endl;*/
        int index = GetIndexPairStateAction(PairStateAction);
=======
        cout << "Element not found in Qtable!!" << endl;*/
        int index = GetIndexPairStateAction(PairStateAction);
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad
        Qtable.at(index).second =  Qtable.at(index).second + QALPHA*(Reward + QGAMMA * Qtarget - Qtable.at(index).second);

}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/*int AGENTQL::GetIndexAction(Action Act)
{

    int i;
    int indice = -1;
    for(i=0;i<ActionsSet->size(); i++)
    {
        if(ActionsSet->at(i).ActFreq == Act.ActFreq)
        {
            indice = i ;
            i = ActionsSet->size();
        }
    }
    return indice;

   // return 0;

<<<<<<< HEAD
}*/
//========================================================================

int AGENTQL::GetIndexPairStateAction(pair < State ,Action > PairStateAction)
{
  int i, IndexPairStateAction; pair < pair < State, Action> , double > p;
   pair < State, Action> MyPair;
   State MyState;
   Action MyAct;
   IndexPairStateAction = -1;
=======
}*/
//========================================================================

int AGENTQL::GetIndexPairStateAction(pair < State ,Action > PairStateAction)
{
  int i, IndexPairStateAction; pair < pair < State, Action> , double > p;
   pair < State, Action> MyPair;
   State MyState;
   Action MyAct;
   IndexPairStateAction = -1;
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad

  for (i=0; i < Qtable.size(); i++)
  {
        p = Qtable.at(i);
         MyPair = p.first;
         MyState = MyPair.first;
<<<<<<< HEAD
         MyAct = MyPair.second;
         if((PairStateAction.first.UnTreatedTRXNumb == MyState.UnTreatedTRXNumb ) && (PairStateAction.second.ActFreq == MyAct.ActFreq))
         {IndexPairStateAction = i;}
=======
         MyAct = MyPair.second;
         if((PairStateAction.first.UnTreatedTRXNumb == MyState.UnTreatedTRXNumb ) && (PairStateAction.second.ActFreq == MyAct.ActFreq))
         {IndexPairStateAction = i;}
>>>>>>> 0514ea9fae0f841576757defb02235a9189b0fad
  }

return IndexPairStateAction;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~éé
/*void AGENTQL::PenalyzeActions( vector <pair <State,Action> > * vect, Individual* solutionRef, int IndexPlayer)
{
    int i,IndexElement; bool test;
    pair < pair < State, Action> , double > p;
    pair < State, Action> P;
    for (i=0; i < vect->size(); i++)
    {
        P = vect->at(i);

        test = CheckElementQtable(P,IndexElement);
        if (test == true)
        {
            //on test si le joeur PI est en train de jouer
            if(IndexPlayer == 1)
            {
                 Qtable->at(IndexElement).second =  Qtable->at(IndexElement).second -solutionRef->planCC->at(i).first;
            }
            else
            {
                if(IndexPlayer == 2)
                {
                    Qtable->at(IndexElement).second =  Qtable->at(IndexElement).second -solutionRef->planCC->at(i).second;
                }
                else
                {
                    cout << " Error, this element doesn't exist in Qtable, check your :PenalyzeActions PROCEDURE" << endl;
                }
            }
        }
        else
        cout << "Error, the element doesn't exist in Qtable!!" << endl;
    }
}
*/
//######################################################"18 -8- 2021 ####################################"
   bool AGENTQL::CheckFinalState(vector<TRXs> LTrxNTreateds)
   {
       if (LTrxNTreateds.empty()== true)
         return true;
       else
        return false;
   }
